
### SAVING AND LOADING ###

class NovelManager

  # Create instance
  instance = null
  constructor: ->
    if instance
      return instance
    else
      instance = this

  # Load a browser cookie
  @loadCookie = (cname) ->
    name = cname + '='
    ca = document.cookie.split(';')
    i = 0
    while i < ca.length
      c = ca[i]
      while c.charAt(0) is ' '
        c = c.substring(1)
      if c.indexOf(name) is 0
        return c.substring(name.length, c.length)
      i++

  # Save a browser cookie
  @saveCookie = (cname, cvalue, exdays) ->
    d = new Date
    d.setTime d.getTime() + exdays * 24 * 60 * 60 * 1000
    expires = 'expires=' + d.toUTCString()
    document.cookie = cname + '=' + cvalue + '; ' + expires + '; path=/'

  # Load the novel from a cookie or entered json
  @loadData: (novel, changeScene) ->
    if changeScene is undefined
      changeScene = true
    if novel is undefined
      if @loadCookie("gameData") isnt ''
        console.log "Cookie found!"
        cookie = @loadCookie("gameData")
        console.log "Cookie loaded"
        console.log cookie
        loadedData = JSON.parse(atob(@loadCookie("gameData")))
        @prepareLoadedData(loadedData, changeScene)
    else if novel isnt undefined and novel isnt ''
      loadedData = JSON.parse(atob(novel))
      @prepareLoadedData(loadedData, changeScene)

  # Prepare the novel from the loaded save file
  @prepareLoadedData = (loadedData, changeScene) ->
    if novelData.novel.name isnt loadedData.name
      console.error "ERROR! novel name mismatch"
      return
    if novelData.novel.version isnt loadedData.version
      console.warn "WARNING! novel version mismatch"
    novelData.novel.inventories = loadedData.inventories
    novelData.debugMode = novelData.novel.debugMode
    SoundManager.init()
    if changeScene
      SceneManager.updateScene(loadedData.currentScene,true)

  # Converts the novel's state into json and Base64 encode it
  @saveDataAsJson = () ->
    # Clone the game data
    saveData = JSON.parse(JSON.stringify(novelData.novel))
    delete saveData.scenes
    delete saveData.tagPresets
    delete saveData.sounds
    delete saveData.externalText
    delete saveData.externalJson
    save = btoa(JSON.stringify(saveData))
    return save

  # Save novel in the defined way
  @saveData: ->
    save = @saveDataAsJson()
    if novelData.novel.settings.saveMode is "cookie"
      @saveCookie("novelData",save,365)
    else if novelData.novel.settings.saveMode is "text"
      UI.showSaveNotification(save)

  # Add values to novel.json that are not defined but are required for Vue.js view updating and other functions
  @prepareData = (json) ->
    # Define variables
    json.currentScene = ""
    json.parsedChoices = ""
    if json.currentInventory is undefined
      json.currentInventory = 0
    if json.inventories is undefined
      json.inventories = [[]]
    console.log json.inventories[0]
    if json.inventories.length is 0
      json.inventories[0] = []
    if json.scenes is undefined
      json.scenes = [{}]
    if json.tagPresets is undefined
      json.tagPresets = []
    if json.sounds is undefined
      json.sounds = []
    for i in json.inventories
      for j in i
        if j.displayName is undefined
          j.displayName = j.name
    # Prepare scenes
    for s in json.scenes
      s.combinedText = ""
      s.parsedText = ""
      s.visited = false
      if s.text is undefined
        console.warn "WARNING! scene "+s.name+" has no text"
        s.text = ""
      if s.choices is undefined
        console.warn "WARNING! scene "+s.name+" has no choices"
        s.choices = []
      for c in s.choices
        c.parsedText = ""
        if c.alwaysShow is undefined
          c.alwaysShow = false
    # Set default settings
    if json.settings is undefined
      json.settings = {}
    if json.settings.debugMode is undefined
      json.settings.debugMode = false
    if json.settings.saveMode is undefined
      json.settings.saveMode = "text"
    if json.settings.language is undefined
      json.settings.language = "english"
    if json.settings.showSaveButtons is undefined
      json.settings.showSaveButtons = true
    if json.settings.showSkipButton is undefined
      json.settings.showSkipButton = false
    if json.settings.inventoryHidden is undefined
      json.settings.inventoryHidden = false
    if json.settings.choicesHidden is undefined
      json.settings.choicesHidden = false
    if json.settings.alwaysShowDisabledChoices is undefined
      json.settings.alwaysShowDisabledChoices = false
    if json.settings.floatPrecision is undefined
      json.settings.floatPrecision = 5
    if json.settings.scrollSettings is undefined
      json.settings.scrollSettings = {}
    if json.settings.scrollSettings.defaultScrollSpeed is undefined
      json.settings.scrollSettings.defaultScrollSpeed = 60
    if json.settings.scrollSettings.revisitSkipEnabled is undefined
      json.settings.scrollSettings.revisitSkipEnabled = true
    if json.settings.scrollSettings.textSkipEnabled is undefined
      json.settings.scrollSettings.textSkipEnabled = true
    if json.settings.scrollSettings.skipWithKeyboard is undefined
      json.settings.scrollSettings.skipWithKeyboard = false
    if json.settings.scrollSettings.continueWithKeyboard is undefined
      json.settings.scrollSettings.continueWithKeyboard = true
    if json.settings.scrollSettings.fastScrollWithKeyboard is undefined
      json.settings.scrollSettings.fastScrollWithKeyboard = true
    if json.settings.scrollSettings.fastScrollSpeedMultiplier is undefined
      json.settings.scrollSettings.fastScrollSpeedMultiplier = 20
    if json.settings.scrollSettings.tickFreqThreshold is undefined
      json.settings.scrollSettings.tickFreqThreshold = 100
    if json.settings.soundSettings is undefined
      json.settings.soundSettings = {}
    if json.settings.soundSettings.soundVolume is undefined
      json.settings.soundSettings.soundVolume = 0.5
    if json.settings.soundSettings.musicVolume is undefined
      json.settings.soundSettings.musicVolume = 0.4
    # Set default UI language values
    if json.uiText is undefined
      json.uiText = JSON.parse('[
        {"name": "saveText", "language": "english", "content": "Copy and save your save data:" },
        {"name": "loadText", "language": "english", "content": "Paste your save data here:" },
        {"name": "closeButton", "language": "english", "content": "Close" },
        {"name": "copyButton", "language": "english", "content": "Copy" },
        {"name": "saveButton", "language": "english", "content": "Save" },
        {"name": "loadButton", "language": "english", "content": "Load" },
        {"name": "skipButton", "language": "english", "content": "Skip" },
        {"name": "continueButton", "language": "english", "content": "Continue" },
        {"name": "inventoryTitle", "language": "english", "content": "Inventory:" },
        {"name": "hiddenInventoryTitle", "language": "english", "content": "Stats:" }
      ]')

  # Start the novel by loading the default novel.json
  @start: ->
    console.log "-- Starting Novel.js... --"
    @loadMainJson()

  # Load the main json
  @loadMainJson = ->
    console.log "Loading main json..."
    request = new XMLHttpRequest
    request.open 'GET', novelPath + '/novel.json', true
    request.onload = ->
      if request.status >= 200 and request.status < 400
        json = JSON.parse(request.responseText)
        NovelManager.loadExternalJson(json)
    request.onerror = ->
      return
    request.send()
    UI.showContinueButton(false)

  # Load external json
  @loadExternalJson = (json) ->
    console.log "Loading external json files..."
    if json.externalJson is undefined
      NovelManager.includeJsons(json,json)
      NovelManager.loadExternalText(json)
      return
    if json.externalJson.length is 0
      NovelManager.includeJsons(json,json)
      NovelManager.loadExternalText(json)
      return
    ready = 0
    for s in json.externalJson
      ((s) ->
        request = new XMLHttpRequest
        request.open 'GET', novelPath + '/json/' + s.file, true
        request.onload = ->
          if request.status >= 200 and request.status < 400
            s.content = JSON.parse(request.responseText)
            ready++
            if ready is json.externalJson.length
              NovelManager.includeJsons(json,json)
              NovelManager.loadExternalText(json)
        request.onerror = ->
          return
        request.send()
      ) s

  # Combine other json objects with the main json
  @includeJsons = (root,object) ->
    if root.externalJson is undefined
      return
    for x of object
      if typeof object[x] is 'object'
        @includeJsons root,object[x]
      if object[x].include isnt undefined
        for i in root.externalJson
          if i.name is object[x].include
            object[x] = i.content
            @includeJsons root,object[x]
            break

  # Load external text files
  @loadExternalText = (json) ->
    console.log "Loading external text files..."
    if json.externalText is undefined
      NovelManager.loadExternalCsv(json)
      return
    if json.externalText.length is 0
      NovelManager.loadExternalCsv(json)
      return
    ready = 0
    for s in json.externalText
      ((s) ->
        request = new XMLHttpRequest
        request.open 'GET', novelPath + '/texts/' + s.file, true
        request.onload = ->
          if request.status >= 200 and request.status < 400
            s.content = request.responseText
            ready++
            if ready is json.externalText.length
              NovelManager.loadExternalCsv(json)
        request.onerror = ->
          return
        request.send()
      ) s

  # Load external CSV files
  @loadExternalCsv = (json) ->
    if novelData.csvEnabled
      console.log "Loading external CSV files..."
      if json.externalText is undefined
        NovelManager.prepareLoadedJson json
        return
      if json.externalText.length is 0
        NovelManager.prepareLoadedJson json
        return
      ready = 0
      for s in json.externalCsv
        Papa.parse novelPath + '/csv/' + s.file,
          download: true
          header: true
          comments: '#'
          complete: (results) ->
            if novelData.csvData is undefined
              novelData.csvData = results.data
            else
              novelData.csvData = Util.mergeObjArrays(novelData.csvData,results.data)
            ready++
            if ready is json.externalCsv.length
              NovelManager.prepareLoadedJson json
    else
      NovelManager.prepareLoadedJson(json)

  # Prepare loaded json data
  @prepareLoadedJson = (json) ->
    @prepareData(json)
    novelData.novel = json
    novelData.debugMode = novelData.novel.debugMode
    SoundManager.init()
    UI.init()
    novelData.novel.currentScene = SceneManager.changeScene(novelData.novel.scenes[0].name)
    novelData.status = "Ready"
    console.log "-- Loading Novel.js complete! --"


### HANDLES KEYBOARD INPUT ###

class InputManager

  # Create instance
  instance = null
  constructor: ->
    if instance
      return instance
    else
      instance = this

  # Set class-wide variables
  @presses: 0

  # Gets key down and handles their functions
  @keyDown: (charCode) ->
    if @formsSelected()
      return
    # Use SPACE to skip or continue
    if (charCode is 13 or charCode is 32)
      if novelData.novel.settings.scrollSettings.continueWithKeyboard
        SceneManager.tryContinue()
      if novelData.novel.settings.scrollSettings.skipWithKeyboard
        TextPrinter.trySkip()
      TextPrinter.unpause()

  # Gets key being pressed
  @keyPressed: (charCode) ->
    if @formsSelected()
      return
    @presses++
    # Use SPACE to fast scroll
    if (charCode is 13 or charCode is 32)
      if @presses > 2
        if novelData.novel.settings.scrollSettings.fastScrollWithKeyboard
          TextPrinter.fastScroll()

  # Gets key release
  @keyUp: (charCode) ->
    if @formsSelected()
      return
    @presses = 0
    # Release SPACE to stop fast scroll
    if (charCode is 13 or charCode is 32)
      TextPrinter.stopFastScroll()

  # Checks if any forms on the page are active
  @formsSelected: ->
    novelArea = document.getElementById("novel-area")
    if novelArea
      inputs = novelArea.querySelectorAll("input")
      for i in inputs
        if i is document.activeElement
          return true
    return false

document.onkeydown = (evt) ->
  evt = evt or window.event
  charCode = evt.keyCode or evt.which
  InputManager.keyDown(charCode)

document.onkeypress = (evt) ->
  evt = evt or window.event
  charCode = evt.keyCode or evt.which
  InputManager.keyPressed(charCode)

document.onkeyup = (evt) ->
  evt = evt or window.event
  charCode = evt.keyCode or evt.which
  InputManager.keyUp(charCode)


### PARSERS ###

class Parser

  # Create instance
  instance = null
  constructor: ->
    if instance
      return instance
    else
      instance = this

  # Select a random scene or choice from a list separated by |, takes string
  @selectRandomOption: (name) ->
    Util.checkFormat(name,'string')
    separate = name.split("|")
    if separate.length is 1
      return separate[0]
    parsed = []
    for i in separate
      i = i.split(",")
      parsed.push(i)
    parsed = @chooseRandomly(parsed)
    return parsed

  # Select a scene or choice randomly from multiple scenes with different probabilities, takes array
  @chooseRandomly = (options) ->
    names = []
    chances = []
    rawChances = []
    previous = 0
    for i in options
      names.push i[0]
      previous = parseFloat(i[1])+previous
      chances.push previous
      rawChances.push parseFloat(i[1])
    totalChance = 0
    for i in rawChances
      totalChance = totalChance + parseFloat(i)
    if totalChance isnt 1
      console.error "ERROR: Invalid scene or choice odds (should add up to exactly 1)!"
    value = Math.random()
    nameIndex = 0
    for i in chances
      if value < i
        return names[nameIndex]
      nameIndex++

  # Parse a string of items and output an array
  @parseItems: (items) ->
    Util.checkFormat(items,'string')
    if items is ""
      return undefined
    separate = items.split("|")
    parsed = []
    for i in separate
      i = i.split(",")
      parsed.push(i)
    return parsed

  # Parse a text for Novel.js tags, and replace them with the correct HTML tags.
  @parseText: (text) ->
    if text isnt undefined
      Util.checkFormat(text,'string')
      if not Util.validateTagParentheses(text)
        console.error "ERROR: Invalid tags in text"
      # External files
      splitText = text.split("[file ")
      for index in [1 .. splitText.length]
        name = ""
        if splitText[index]
          for i in splitText[index].split('')
            if i isnt ']'
              name = name + i
            else
              break
        # Clean spaces
        name = name.replace(/\s+/g, '');
        # If name detected
        if name isnt ""
          newText = null
          # Find external text by name
          for i in novelData.novel.externalText
            if i.name is name
              newText = i.content
              break
          # If not found from files, get from CSV data
          if newText is null
            newText = LanguageManager.getCorrectLanguageCsvString(name)
          # Replace the text
          if newText isnt null
            text = text.split("[file "+name+"]").join(newText)
      # [p] tags
      for i in novelData.novel.tagPresets
        tagName = "[p " + i.name + "]"
        if text.indexOf(tagName) > -1
          text = text.split(tagName).join(i.start)
        tagName = "[/p " + i.name + "]"
        if text.indexOf(tagName) > -1
          text = text.split(tagName).join(i.end)
      # [s] tags
      for i in [0 .. 99]
        text = text.split("[s" + i + "]").join("<span class=\"highlight-" + i + "\">")
      text = text.split("[/s]").join("</span>")
      # Ignore /[ and /]
      text = text.replace(/\/\[/g, "OPEN_BRACKET_REPLACEMENT").replace(/\/\]/g, "CLOSE_BRACKET_REPLACEMENT")
      splitText = text.split(/\[|\]/)
      index = 0
      for s in splitText
        splitText[index] = s.replace(/OPEN_BRACKET_REPLACEMENT/g,"[").replace(/CLOSE_BRACKET_REPLACEMENT/g,"]")
        index++
      # Other tags
      spansToBeClosed = 0
      asToBeClosed = 0
      index = 0
      for index in [0 .. splitText.length-1]
        s = splitText[index]
        # [if] statements
        if s.substring(0,2) is "if"
          parsed = s.split("if ")
          if not @parseStatement(parsed[1])
            splitText[index] = "<span style=\"display:none;\">"
            spansToBeClosed++
          else
            splitText[index] = ""
        # Endif
        else if s.substring(0,3) is "/if"
          if spansToBeClosed > 0
            splitText[index] = "</span>"
            spansToBeClosed--
          else
            splitText[index] = ""
        # Printed inventory counts
        else if s.substring(0,4) is "inv."
          value = s.substring(4,s.length)
          splitText[index] = 0
          for i in novelData.novel.inventories[novelData.novel.currentInventory]
            if i.name is value
              splitText[index] = i.value
        # Generic print command
        else if s.substring(0,5) is "print"
          parsed = s.split("print ")
          parsed = @parseStatement(parsed[1])
          if not isNaN(parseFloat(parsed))
            parsed = parseFloat(parsed.toFixed(novelData.novel.settings.floatPrecision))
          splitText[index] = parsed
        # Execute JavaScript
        else if s.substring(0,4) is "exec"
          parsed = s.substring(5,s.length)
          p = novelData.parsedJavascriptCommands.push(parsed)
          p--
          splitText[index] = "<span class=\"execute-command com-" + p + "\"></span>"
        # Pause
        else if s.substring(0,5) is "pause"
          parsed = s.substring(6,s.length)
          splitText[index] = "<span class=\"pause " + parsed + "\"></span>"
        # Play sound
        else if s.substring(0,5) is "sound"
          parsed = s.split("sound ")
          splitText[index] = "<span class=\"play-sound " + parsed[1] + "\"></span>"
        # Stop music
        else if s.substring(0,6) is "/music"
          parsed = s.split("/music ")
          splitText[index] = "<span class=\"stop-music " + parsed[1] + "\"></span>"
        # Play music
        else if s.substring(0,5) is "music"
          parsed = s.split("music ")
          splitText[index] = "<span class=\"play-music " + parsed[1] + "\"></span>"
        # Reset text speed
        else if s.substring(0,6) is "/speed"
          splitText[index] = "<span class=\"default-speed\"></span>"
        # Change speed
        else if s.substring(0,5) is "speed"
          parsed = s.split("speed ")
          splitText[index] = "<span class=\"set-speed " + parsed[1] + "\"></span>"
        # Reset scroll sound
        else if s.substring(0,12) is "/scrollSound"
          splitText[index] = "<span class=\"default-scroll-sound\"></span>"
        # Scroll sound
        else if s.substring(0,11) is "scrollSound"
          parsed = s.split("scrollSound ")
          splitText[index] = "<span class=\"set-scroll-sound " + parsed[1] + "\"></span>"
        # Input field
        else if s.substring(0,5) is "input"
          parsed = s.split("input ")
          nameText = ""
          for i in novelData.novel.inventories[novelData.novel.currentInventory]
            if i.name is parsed[1]
              nameText = i.value
          splitText[index] = "<input type=\"text\" value=\"" + nameText + "\" name=\"input\" class=\"input-" + parsed[1] +  "\" onblur=\"UI.updateInputs(true)\">"
        # Embedded choice
        else if s.substring(0,6) is "choice"
          parsed = s.split("choice ")
          splitText[index] = "<a href=\"#\" onclick=\"SceneManager.selectChoiceByNameByClicking(event,'"+parsed[1]+"')\">"
          asToBeClosed++
        # Choice end
        else if s.substring(0,7) is "/choice"
          if asToBeClosed > 0
            splitText[index] = "</a>"
            asToBeClosed--
          else
            splitText[index] = ""
        index++
      # Join all back into a string
      text = splitText.join("")
      #if novelData.markdownEnabled
      #  text = marked(text)
      return text

  # Parse a statement that returns true or false or calculate a value
  @parseStatement: (s) ->
    if s is undefined
      return undefined
    s = s.toString()
    Util.checkFormat(s,'string')
    # Check for valid parentheses
    if not Util.validateParentheses(s)
      console.error "ERROR: Invalid parentheses in statement"
    # Clean spaces
    s = s.replace(/\s+/g, '');
    # Remove all operators and parentheses
    parsedString = s.split(/\(|\)|\+|\*|\-|\/|<=|>=|<|>|==|!=|\|\||&&/)
    parsedValues = []
    # Parse the strings for known prefixes, and parse the values based on that.
    for val in parsedString
      type = @getStatementType(val)
      switch type
        # Parse item
        when "item"
          found = false
          for i in novelData.novel.inventories[novelData.novel.currentInventory]
            if i.name is val.substring(4,val.length)
              parsedValues.push i.value
              found = true
          if not found
            parsedValues.push 0
        # Generate a random value
        when "rand"
          val = val.split(".")
          vals = val[1].split(",")
          plus = true
          if vals[0].substring(0,5) is "minus"
            vals[0] = vals[0].substring(5,vals[0].length)
            plus = false
          if vals[1].substring(0,5) is "minus"
            vals[1] = vals[1].substring(5,vals[1].length)
            plus = false
          if plus
            result = Math.random()*vals[1] + vals[0]
          else
            result = Math.random()*vals[1] - vals[0]
          if vals[2] is undefined
            vals[2] = 0
          if vals[2] is 0
            result = Math.round(result)
          else
            result = parseFloat(result).toFixed(vals[2])
          parsedValues.push result
        # Parse variable
        when "var"
          val = @findValue(val.substring(4,val.length),true)
          if not isNaN(parseFloat(val))
            val = parseFloat(val).toFixed(novelData.novel.settings.floatPrecision)
          else
            val = "'" + val + "'"
          parsedValues.push val
        # Parse float
        when "float"
          parsedValues.push parseFloat(val).toFixed(novelData.novel.settings.floatPrecision)
        # Parse int
        when "int"
          parsedValues.push parseInt(val)
        # Parse string
        when "string"
          if val isnt ""
            parsedValues.push "'" + val + "'"
          else
            parsedValues.push ""
    # Replace all variables with their correct values
    for i in [0 .. parsedString.length-1]
      if parsedString[i] isnt "" and parsedValues[i] isnt ""
        s = s.replace(new RegExp(parsedString[i],'g'),parsedValues[i])
        s = s.replace(new RegExp("''",'g'),"'") # Remove double-':s caused by string parsing
    # Solve or calculate the statement
    returnVal = eval(s)
    # Fix booleans
    if returnVal is "true"
      returnVal = true
    if returnVal is "false"
      returnVal = false
    # Return the actual result
    return returnVal

  # Read a string's beginning to detect its type
  @getStatementType: (val) ->
    type = null
    if val.substring(0,4) is "inv."
      type = "item"
    else if val.substring(0,4) is "var."
      type = "var"
    else if val.substring(0,5) is "rand."
      type = "rand"
    else if not isNaN(parseFloat(val)) and val.toString().indexOf(".") is -1
      type = "int"
    else if not isNaN(parseFloat(val)) and val.toString().indexOf(".") isnt -1
      type = "float"
    else
      type = "string"
    return type

  # Find a value from the game novelData json
  # toPrint is true returns the value, toPrint is false returns the object
  @findValue: (parsed, toPrint) ->
    splitted = parsed.split(",")
    # Find the first object in hierarchy
    if not toPrint
      if splitted.length > 1
        variable = @findValueByName(novelData.novel,splitted[0])[0]
      else
        variable = @findValueByName(novelData.novel,splitted[0])[1]
    else
      variable = @findValueByName(novelData.novel,splitted[0])[0]
    # Follow the path
    for i in [0 .. splitted.length - 1]
      if Util.isOdd(i)
        variable = variable[parseInt(splitted[i])]
      else if i isnt 0
        if not toPrint
          variable = @findValueByName(variable,splitted[i])[1]
        else
          if splitted[i] is "parsedText" or splitted[i] is "text"
            splitted[i] = "parsedText"
            variable.parsedText = @parseText(variable.text)
          variable = @findValueByName(variable,splitted[i])[0]
    if variable is undefined
      console.warn "WARNING: Searched value not found."
    return variable

  # Find an object from the object hierarchy by string name
  @findValueByName: (obj, string) ->
    Util.checkFormat(string,'string')
    parts = string.split('.')
    newObj = obj[parts[0]]
    if parts[1]
      parts.splice 0, 1
      newString = parts.join('.')
      return @findValueByName(newObj, newString)
    r = []
    r[0] = newObj
    r[1] = obj
    return r


### INVENTORY, STAT & VALUE OPERATIONS ###

class InventoryManager

  # Create instance
  instance = null
  constructor: ->
    if instance
      return instance
    else
      instance = this

  # Check if item or stat requirements have been filled
  @checkRequirements: (requirements) ->
    Util.checkFormat(requirements,'array')
    reqsFilled = 0
    # Go through all requirements
    for i in novelData.novel.inventories[novelData.novel.currentInventory]
      for j in requirements
        if j[0] is i.name
          if j[1] <= i.value
            reqsFilled = reqsFilled + 1
    # Check whether all requirements have been filled
    if reqsFilled is requirements.length
      return true
    else
      return false

  # Set a value in JSON
  @setValue: (parsed, newValue) ->
    Util.checkFormat(parsed,'string')
    getValueArrayLast = @getValueArrayLast(parsed)
    value = Parser.findValue(parsed,false)
    value[getValueArrayLast] = newValue

  # Increase a value in JSON
  @increaseValue: (parsed, change) ->
    Util.checkFormat(parsed,'string')
    getValueArrayLast = @getValueArrayLast(parsed)
    value = Parser.findValue(parsed,false)
    value[getValueArrayLast] = value[getValueArrayLast] + change
    if not isNaN(parseFloat(value[getValueArrayLast]))
      value[getValueArrayLast] = parseFloat(value[getValueArrayLast].toFixed(novelData.novel.settings.floatPrecision));

  # Decrease a value in JSON
  @decreaseValue: (parsed, change) ->
    Util.checkFormat(parsed,'string')
    getValueArrayLast = @getValueArrayLast(parsed)
    value = Parser.findValue(parsed,false)
    value[getValueArrayLast] = value[getValueArrayLast] - change
    if not isNaN(parseFloat(value[getValueArrayLast]))
      value[getValueArrayLast] = parseFloat(value[getValueArrayLast].toFixed(novelData.novel.settings.floatPrecision));

  # Get the last item in a value array
  @getValueArrayLast: (parsed) ->
    getValueArrayLast = parsed.split(",")
    getValueArrayLast = getValueArrayLast[getValueArrayLast.length-1].split(".")
    getValueArrayLast = getValueArrayLast[getValueArrayLast.length-1]
    return getValueArrayLast

  # Add items
  @addItems: (items) ->
    @editItems(items, "add")

  # Set items
  @setItems: (items) ->
    @editItems(items, "set")

  # Remove items
  @removeItems: (items) ->
    @editItems(items, "remove")

  # Edit the player's items or stats
  @editItems = (items, mode) ->
    Util.checkFormat(items,'array')
    for j in items
      hidden = false
      # If the item name begins with a "!", it is hidden
      if j[0].substring(0,1) is "!"
        hidden = true
        j[0] = j[0].substring(1,j[0].length)
      # Try to edit the item in the current inventory
      itemAdded = @tryEditInInventory(mode, j, hidden);
      # If it failed, add a new item
      if not itemAdded
        @tryEditNotInInventory(mode, j, hidden)

  # Try to edit an existing item
  @tryEditInInventory = (mode, j, hidden) ->
    for i in novelData.novel.inventories[novelData.novel.currentInventory]
      # If the item exists in the current inventory
      if i.name is j[0]
        probability = 1
        # Check the string for display names and probabilities
        if j.length > 2
          displayName = j[2]
          value = parseInt(Parser.parseStatement(j[1]))
          if not isNaN(displayName)
            probability = j[2]
            displayName = j.name
          if j.length > 3
            probability = parseFloat(j[2])
            displayName = j[3]
        else
          displayName = j[0]
          value = parseInt(Parser.parseStatement(j[1]))
        # Generate a random value to determine whether to continue
        random = Math.random()
        if random < probability
          # Set the item's value
          if (mode is "set")
            if isNaN parseInt(j[1])
              i.value = j[1]
            else
              i.value = parseInt(j[1])
          # Add to the item's value - if it was a string, change it into a number
          else if (mode is "add")
            if isNaN parseInt(i.value)
              i.value = 0
            i.value = parseInt(i.value) + value
          # Deduct from the item's value - if it's a string, change it into 0
          else if (mode is "remove")
            if not isNaN parseInt(i.value)
              i.value = parseInt(i.value) - value
              if i.value < 0
                i.value = 0
            else
              i.value = 0
          # Set whether to hide the item or not
          i.hidden = hidden
        return true
    return false

  # Edit an item that does not exist in inventory yet
  @tryEditNotInInventory = (mode, j, hidden) ->
    # Only do this if we don't want to remove anything
    if mode isnt "remove"
      probability = 1
      # Check the string for display names and probablities
      value = parseInt(Parser.parseStatement(j[1]))
      if isNaN value
        value = Parser.parseStatement(j[1])
      if j.length > 2
        displayName = j[2]
        if not isNaN(displayName)
          probability = j[2]
          displayName = j.name
        if j.length > 3
          probability = parseFloat(j[2])
          displayName = j[3]
      else
        displayName = j[0]
      random = Math.random()
      # Set the display name
      if displayName is undefined
        displayName = j[0]
      # If we're lucky enough, add the new item
      if random < probability
        novelData.novel.inventories[novelData.novel.currentInventory].push({"name": j[0], "value": value, "displayName": displayName, "hidden": hidden})


### HANDLES LANGUAGE SETTINGS ###

class LanguageManager

  # Create instance
  instance = null
  constructor: ->
    if instance
      return instance
    else
      instance = this

  # Change the novel's language
  @setLanguage = (name) ->
    novelData.novel.settings.language = name
    UI.updateUILanguage()

  # Get a string shown in UI in the current language
  @getUIString = (name) ->
    Util.checkFormat(name,'string')
    for i in novelData.novel.uiText
      if i.name is name and i.language is novelData.novel.settings.language
        return Parser.parseText(i.content)
    console.error 'Error! UI string ' + name + ' not found!'
    return '[NOT FOUND]'

  # Get the correct version of csv string
  @getCorrectLanguageCsvString = (name) ->
    Util.checkFormat(name,'string')
    if novelData.csvData is undefined or novelData.csvEnabled is false
      console.error "Error! CSV data cannot be parsed, because Papa Parse can't be detected."
      return '[NOT FOUND]'
    for i in novelData.csvData
      if i.name is name
        if i[novelData.novel.settings.language] is undefined
          if i['english'] is undefined
            console.error 'Error! No CSV value by name ' + name + ' could be found.'
            return '[NOT FOUND]'
          return Parser.parseText(i['english'])
        return Parser.parseText(i[novelData.novel.settings.language])

  # Get an item's attribute in the correct language
  @getItemAttribute = (item, type) ->
    switch type
      when 'displayName'
        if item.displayName is '[csv]'
          return @getCorrectLanguageCsvString(item.name + '|displayName')
        else
          return @getCorrectLanguageString(item.displayName)
        break
      when 'description'
        if item.description is '[csv]'
          return @getCorrectLanguageCsvString(item.name + '|description')
        else
          return @getCorrectLanguageString(item.description)
        break
      else
        console.error 'Error! Trying to get an invalid item attribute in LanguageManager.'
        return '[NOT FOUND]'
        break

  # Get the string in the correct language
  @getCorrectLanguageString = (obj, type) ->
    Util.checkFormat(obj,'arrayOrString')
    if typeof obj is "string"
      return obj
    if Object::toString.call(obj) is '[object Array]'
      for i in obj
        if i.language is novelData.novel.settings.language
          return i.content


### SCENE MANIPULATION ###

class SceneManager

  # Create instance
  instance = null
  constructor: ->
    if instance
      return instance
    else
      instance = this

  # Try to select "Continue"
  @tryContinue: ->
    if TextPrinter.printCompleted and TextPrinter.tickSpeedMultiplier is 1
      @selectChoiceByName("Continue")

  # Select a choice
  @selectChoice: (choice) ->
    @exitScene(novelData.novel.currentScene)
    @readItemEdits(choice)
    @readSounds(choice,true)
    @readSaving(choice)
    @readExecutes(choice)
    @readCheckpoints(choice)
    @readLanguage(choice)
    # Move to the next scene or choice
    if choice.nextScene isnt undefined
      @changeScene(choice.nextScene)
    else
      if choice.nextChoice isnt undefined
        @selectChoiceByName(Parser.selectRandomOption(choice.nextChoice))
      else
        @updateScene(novelData.novel.currentScene,true)
    UI.updateInventories()

  # Select a choice by clicking a link embedded in text
  @selectChoiceByNameByClicking: (event, name) ->
    event.stopPropagation()
    event.preventDefault()
    @selectChoiceByName(name)

  # Select a choice by name
  @selectChoiceByName: (name) ->
    for i in novelData.novel.currentScene.choices
      if i.name is name
        @selectChoice(i)
        break

  # Select a choice by ID
  @selectChoiceById: (id) ->
    if novelData.novel.currentScene.choices[id]
      @selectChoice(novelData.novel.currentScene.choices[id])

  # Called when exiting a scene
  @exitScene = (scene) ->
    # Set the previous scene as visited
    scene.visited = true
    UI.updateInputs(false)
    UI.resetChoices()

  # Called when changing a scene
  @changeScene = (sceneNames) ->
    # Load the new scene
    Util.checkFormat(sceneNames,'string')
    scene = @findSceneByName(Parser.selectRandomOption sceneNames)
    @setupScene(scene)
    return scene

  # Setup a scene changed to
  @setupScene = (scene) ->
    @updateScene(scene, false)
    @readItemEdits(novelData.novel.currentScene)
    @readSounds(novelData.novel.currentScene,false)
    @readSaving(novelData.novel.currentScene)
    @readExecutes(novelData.novel.currentScene)
    @readCheckpoints(novelData.novel.currentScene)
    @readLanguage(novelData.novel.currentScene)
    @readMisc(novelData.novel.currentScene)
    # Show the hidden inventory items based on debug mode
    UI.showHiddenInventoryArea()
    # Finally print the scene's text
    TextPrinter.printText(scene.parsedText,false)

  # If not changing scenes but update needed, this is called
  @updateScene = (scene, onlyUpdating) ->
    # Handle the scene text
    scene = @combineSceneTexts(scene)
    scene.parsedText = Parser.parseText scene.combinedText
    # Set the current scene
    novelData.novel.currentScene = scene
    # Update scene style
    UI.updateStyle(scene.style)
    # Make the next steps
    if not onlyUpdating
      novelData.novel.parsedChoices = null
    else
      TextPrinter.printText(scene.parsedText,true)
      TextPrinter.complete()

  # Return a scene by its name; throw an error if not found.
  @findSceneByName = (name) ->
    Util.checkFormat(name,'string')
    for i in novelData.novel.scenes
      if i.name is name
        return i
    console.error "ERROR: Scene by name '"+name+"' not found!"

  # Combine the multiple scene text rows
  @combineSceneTexts = (s) ->
    Util.checkFormat(s,'object')
    Util.checkFormat(s.text,'arrayOrString')
    s.combinedText = ""
    if Object.prototype.toString.call(s.text) is "[object Array]"
      for i in s.text
        # Rows should be formatted into paragraphs
        s.combinedText = s.combinedText + "<p>" + LanguageManager.getCorrectLanguageString(i) + "</p>"
    else
      s.combinedText = s.text
    return s

  # Read item and val edit commands from scene or choice
  @readItemEdits = (source) ->
    # Handle inventory changing
    if source.changeInventory isnt undefined
      novelData.novel.currentInventory = Parser.parseStatement(source.changeInventory)
      if novelData.novel.currentInventory > novelData.novel.inventories.length
        for i in [0 .. novelData.novel.currentInventory]
          if novelData.novel.inventories[i] is undefined
            novelData.novel.inventories[i] = []
    # Handle item removal
    if source.removeItem isnt undefined
      InventoryManager.removeItems(Parser.parseItems(source.removeItem))
    # Handle item adding
    if source.addItem isnt undefined
      InventoryManager.addItems(Parser.parseItems(source.addItem))
    # Handle item value setting
    if source.setItem isnt undefined
      InventoryManager.setItems(Parser.parseItems(source.setItem))
    # Handle object value setting
    if source.setValue isnt undefined
      for val in source.setValue
        InventoryManager.setValue(val.path,Parser.parseStatement(val.value.toString()))
    if source.increaseValue isnt undefined
      for val in source.increaseValue
        InventoryManager.increaseValue(val.path,Parser.parseStatement(val.value.toString()))
    if source.decreaseValue isnt undefined
      for val in source.decreaseValue
        InventoryManager.decreaseValue(val.path,Parser.parseStatement(val.value.toString()))

  # Read sound commands from scene or choice
  @readSounds = (source, clicked) ->
    played = false
    # If should play a sound
    if source.playSound isnt undefined
      SoundManager.playSound(Parser.parseStatement(source.playSound),false)
      played = true
    # If no other sound was played, play the default click sound
    if clicked and not played
      SoundManager.playDefaultClickSound()
    # Start music
    if source.startMusic isnt undefined
      SoundManager.startMusic(Parser.parseStatement(source.startMusic))
    # Stop music
    if source.stopMusic isnt undefined
      SoundManager.stopMusic(Parser.parseStatement(source.stopMusic))
    # Scene-specific scrolling sound
    if source.scrollSound isnt undefined
      novelData.novel.currentScene.scrollSound = Parser.parseStatement(source.scrollSound)
    else
      if novelData.novel.settings.soundSettings.defaultScrollSound
        novelData.novel.currentScene.scrollSound = novelData.novel.settings.soundSettings.defaultScrollSound
      else
        novelData.novel.currentScene.scrollSound = undefined

  # Read JS commands
  @readExecutes = (source) ->
    # Execute found JS
    if source.executeJs isnt undefined
      eval(source.executeJs)

  # Language changing
  @readLanguage = (source) ->
    # Check if changing language
    if source.setLanguage isnt undefined
      LanguageManager.setLanguage(source.setLanguage)

  # Read miscellaneous scene values
  @readMisc = (source) ->
    # Check if skipping is enabled in this scene
    if source.skipEnabled isnt undefined
      val = Parser.parseStatement(source.skipEnabled)
    else
      val = novelData.novel.settings.scrollSettings.textSkipEnabled
    novelData.novel.currentScene.skipEnabled = val
    UI.showSkipButton(val)
    # Check if revisit skipping is enabled in this scene
    if source.revisitSkipEnabled isnt undefined
      novelData.novel.currentScene.revisitSkipEnabled = Parser.parseStatement(source.revisitSkipEnabled)
    else
      novelData.novel.currentScene.revisitSkipEnabled = novelData.novel.settings.scrollSettings.revisitSkipEnabled
    # Check if scroll speed setting is enabled
    if source.scrollSpeed isnt undefined
      novelData.novel.currentScene.scrollSpeed = source.scrollSpeed
    else
      novelData.novel.currentScene.scrollSpeed = novelData.novel.settings.scrollSettings.defaultScrollSpeed
    # Check if inventory hiding is enabled
    if source.inventoryHidden isnt undefined
      val = Parser.parseStatement(source.inventoryHidden)
    else
      val = novelData.novel.settings.inventoryHidden
    novelData.inventoryHidden = val
    UI.showInventoryArea(!val)
    # Check if choice hiding is enabled
    if source.choicesHidden isnt undefined
      val = Parser.parseStatement(source.choicesHidden)
    else
      val = novelData.novel.settings.choicesHidden
    novelData.choicesHidden = val
    UI.showChoicesArea(!val)
    # Check if choice hiding is enabled
    if source.saveButtonsHidden isnt undefined
      val = Parser.parseStatement(source.saveButtonsHidden)
    else
      val = !novelData.novel.settings.showSaveButtons
    novelData.saveButtonsHidden = val
    UI.showSaveButtons(!val)

  # Read save and load commands from scene or choice
  @readSaving = (source) ->
    if source.save isnt undefined
      NovelManager.saveData()
    if source.load isnt undefined
      UI.showLoadNotification()

  # Read checkpoint commands
  @readCheckpoints = (source) ->
    # Save a new checkpoint
    if source.saveCheckpoint isnt undefined
      # Generate checkpoints object if not defined
      if novelData.novel.checkpoints is undefined
        novelData.novel.checkpoints = []
      dataChanged = false
      # Try to set a checkpoint
      for i in novelData.novel.checkpoints
        if i.name is Parser.parseStatement(source.saveCheckpoint)
          i.scene = novelData.novel.currentScene.name
          dataChanged = true
      # If an existing checkpoint was not found, create a new one
      if not dataChanged
        checkpoint = { name: Parser.parseStatement(source.saveCheckpoint), scene: novelData.novel.currentScene.name }
        novelData.novel.checkpoints.push(checkpoint)
    # Load a checkpoint if able
    if source.loadCheckpoint isnt undefined
      # Generate a checkpoints object if not defined
      if novelData.novel.checkpoints is undefined
        novelData.novel.checkpoints = []
      for i in novelData.novel.checkpoints
        if i.name is Parser.parseStatement(source.loadCheckpoint)
          @changeScene(i.scene)

  # Check whether the requirements for a choice have been met
  @requirementsFilled = (choice) ->
    reqs = []
    # Check the item requirement
    if choice.itemRequirement isnt undefined
      requirements = Parser.parseItems choice.itemRequirement
      reqs.push InventoryManager.checkRequirements requirements
    # Check the requirement statement
    if choice.requirement isnt undefined
      reqs.push Parser.parseStatement choice.requirement
    success = true
    # If both were satisfied, return true
    for r in reqs
      if r is false
        success = false
    return success


### SOUNDS ###

# A class for sound functions
class SoundManager

  # Create instance
  instance = null
  constructor: ->
    if instance
      return instance
    else
      instance = this

  # Load all sounds
  @init: () ->
    index = 0
    for s in novelData.novel.sounds
      s.sound = new Audio(novelPath+'/sounds/'+s.file)
      index++

  # Play the default sound for clicking an item
  @playDefaultClickSound: (name,clicked) ->
    @playSound(novelData.novel.settings.soundSettings.defaultClickSound,false)

  # Play a sound by name
  @playSound: (name, isMusic) ->
    if name is undefined
      return
    name = Parser.selectRandomOption(name);
    for s in novelData.novel.sounds
      if s.name is name
        sound = s.sound
        if isMusic
          sound.volume = novelData.novel.settings.soundSettings.musicVolume
        else
          sound.volume = novelData.novel.settings.soundSettings.soundVolume
        sound.play()
        return sound

  # Is music playing?
  @isPlaying: (name) ->
    for i in novelData.music
      if i.paused
        return false
      else
        return true

  # Start music
  @startMusic: (name) ->
    for m in novelData.music
      if m.name is name
        return
    music = @playSound(name,true)
    if music is undefined
      return
    music.addEventListener 'ended', (->
      @currentTime = 0
      @play()
      return
    ), false
    novelData.music.push {"name":name,"music":music}

  # Stop a music that was started previously
  @stopMusic: (name) ->
    for i in novelData.music
      if name is i.name
        i.music.pause()
        index = novelData.music.indexOf(i)
        novelData.music.splice(index,1)


### TEXT PRINTING (letter by letter etc.) ###

class TextPrinter

  # Create instance
  instance = null
  constructor: ->
    if instance
      return instance
    else
      instance = this

  # Define class-wide variables
  @fullText: ""
  @currentText: ""
  @currentOffset: 0
  @defaultInterval: 0
  @soundBuffer: []
  @musicBuffer: []
  @stopMusicBuffer: []
  @executeBuffer: []
  @buffersExecuted: false
  @scrollSound: null
  @tickSoundFrequency: 1
  @tickCounter: 0
  @tickSpeedMultiplier: 1
  @speedMod: false
  @pause: 0
  @interval: 0
  @printCompleted: false

  # Print a scene's text - noBuffers prevents buffers from replaying when scene is not changed
  @printText: (text, noBuffers) ->
    @printCompleted = false
    @currentText = ""
    UI.updateText(@currentText)
    # Disable the skip button
    UI.disableSkipButton()
    # Hide the continue button
    UI.showContinueButton(false)
    @fullText = text
    #console.log fullText
    @currentOffset = -1
    @soundBuffer = []
    @musicBuffer = []
    @stopMusicBuffer = []
    @executeBuffer = []
    @buffersExecuted = false
    if noBuffers
      @buffersExecuted = true
    @defaultInterval = novelData.novel.currentScene.scrollSpeed
    @setTickSoundFrequency(@defaultInterval)
    if novelData.novel.currentScene.visited and novelData.novel.currentScene.revisitSkipEnabled
      @complete()
      return
    setTimeout(@onTick(),@defaultInterval)

  # Try to skip text, if allowed
  @trySkip: ->
    if novelData.novel.currentScene.skipEnabled
      @complete()

  # Instantly show all text
  @complete: ->
    @printCompleted = true
    @currentOffset = 0
    # Re-enable skip button
    UI.enableSkipButton()
    # Play missed sounds and start missed music
    if not @buffersExecuted
      ss = []
      first = true
      # Play missed sounds
      if @fullText.indexOf("play-sound") > -1
        s = @fullText.split("play-sound ")
        for i in s
          if not first
            ss.push(i.split(/\s|\"/)[0])
          first = false
      if ss.length > 0
        for i in [0 .. ss.length]
          if not (ss[i] in @soundBuffer)
            SoundManager.playSound(Parser.parseStatement(ss[i]))
      ss = []
      first = true
      # Play missed music
      if @fullText.indexOf("play-music") > -1
        s = @fullText.split("play-music ")
        for i in s
          if not first
            ss.push(i.split(/\s|\"/)[0])
          first = false
      if ss.length > 0
        for i in [0 .. ss.length]
          if not (ss[i] in @musicBuffer)
            SoundManager.startMusic(Parser.parseStatement(ss[i]))
      ss = []
      first = true
      # Stop missed music
      if @fullText.indexOf("stop-music") > -1
        s = @fullText.split("stop-music ")
        for i in s
          if not first
            ss.push(i.split(/\s|\"/)[0])
          first = false
      if ss.length > 0
        for i in [0 .. ss.length]
          if not (ss[i] in @stopMusicBuffer)
            SoundManager.stopMusic(Parser.parseStatement(ss[i]))
      ss = []
      first = true
      # Execute missed commands
      if @fullText.indexOf("execute-command") > -1
        s = @fullText.split("execute-command ")
        for i in s
          if not first
            ss.push(i.split(/\s|\"/)[0])
          first = false
      if ss.length > 0
        for i in [0 .. ss.length]
          if not (ss[i] in @executeBuffer) and ss[i] isnt undefined
            eval(novelData.parsedJavascriptCommands[parseInt(ss[i].substring(4,ss[i].length))])
      @buffersExecuted = true
    # Set printed text and update choices
    @currentText = @fullText
    UI.updateText(@currentText)
    UI.updateChoices()

  # Stop pause
  @unpause: () ->
    UI.showContinueButton(false)
    if @pause is "input"
      @pause = 0

  # Fast text scrolling
  @fastScroll: () ->
    if novelData.novel.currentScene.skipEnabled
      @tickSpeedMultiplier = novelData.novel.settings.scrollSettings.fastScrollSpeedMultiplier

  # Stop fast text scrolling
  @stopFastScroll: () ->
    @tickSpeedMultiplier = 1

  # Set how frequently the scrolling sound is played
  @setTickSoundFrequency: (freq) ->
    threshold = novelData.novel.settings.scrollSettings.tickFreqThreshold
    @tickSoundFrequency = 1
    if freq <= (threshold * 2)
      @tickSoundFrequency = 2
    if freq <= (threshold)
      @tickSoundFrequency = 3

  # Show a new letter
  @onTick = ->
    # Do not continue if paused
    if @pause isnt "input" and @pause > 0
      @pause--
    # Continue if not paused
    if @pause is 0
      if not @speedMod
        @interval = @defaultInterval
      # Instantly finish if interval is 0
      if @defaultInterval is 0
        @complete()
        return
      # Return if all text is printed
      if @currentText is @fullText
        return
      # Parse tags
      offsetChanged = false
      while (@fullText[@currentOffset] is ' ' || @fullText[@currentOffset] is '<' || @fullText[@currentOffset] is '>')
        @readTags()
      # Move forward
      @currentText = @fullText.substring(0, @currentOffset)
      UI.updateText(@currentText)
      if not offsetChanged
        @currentOffset++
      # Complete if printing finished
      if @currentOffset >= @fullText.length
        @complete()
        return
      # Play tick sounds
      @tickCounter++
      if @tickCounter >= @tickSoundFrequency
        if @scrollSound isnt "none" and @interval isnt 0
          if @scrollSound isnt null
            SoundManager.playSound(@scrollSound)
          else if (novelData.novel.currentScene.scrollSound isnt undefined)
            SoundManager.playSound(novelData.novel.currentScene.scrollSound)
          @tickCounter = 0
    # Set the tick sound frequency
    @setTickSoundFrequency(@interval / @tickSpeedMultiplier)
    # Set the timeout until the next tick
    setTimeout (->
      TextPrinter.onTick()
      return
    ), @interval / @tickSpeedMultiplier

  # Skip chars that are not printed, and parse tags
  @readTags = ->
    # Skip spaces and tag enders
    if @fullText[@currentOffset] is ' '
      @currentOffset++
    if @fullText[@currentOffset] is '>'
      @currentOffset++
    # Tag starter found, start reading
    if @fullText[@currentOffset] is '<'
      i = @currentOffset
      str = ""
      i++
      # Read the tag
      while (@fullText[i-1] isnt '>' and @fullText[i] isnt '<')
        str = str + @fullText[i]
        i++
      str = str.substring(1,str.length)
      # Do not print hidden text
      if str.indexOf("display:none;") > -1
        disp = ""
        spans = 1
        while true
          i++
          disp = disp + @fullText[i]
          if disp.indexOf("/span") isnt -1
            spans--
            disp = ""
          else if disp.indexOf("span") isnt -1
            spans++
            disp = ""
          if spans is 0
            break
        i++
      # Buffering of hidden commands
      # Sound playing
      if str.indexOf("play-sound") > -1 and str.indexOf("display:none;") > -1
        s = str.split("play-sound ")
        s = s[1].split(/\s|\"/)[0]
        @soundBuffer.push(Parser.parseStatement(s))
      # Music playing
      if str.indexOf("play-music") > -1 and str.indexOf("display:none;") > -1
        s = str.split("play-music ")
        s = s[1].split(/\s|\"/)[0]
        @musicBuffer.push(Parser.parseStatement(s))
      # Music stopping
      if str.indexOf("stop-music") > -1 and str.indexOf("display:none;") > -1
        s = str.split("stop-music ")
        s = s[1].split(/\s|\"/)[0]
        @stopMusicBuffer.push(Parser.parseStatement(s))
      # Command executing
      if str.indexOf("execute-command") > -1 and str.indexOf("display:none;") > -1
        s = str.split("execute-command ")
        s = s[1].split(/\s|\"/)[0]
        @executeBuffer.push(Parser.parseStatement(s))
      # Executing of non-hidden commands
      if str.indexOf("display:none;") is -1
        # Sound playing
        if str.indexOf("play-sound") > -1
          s = str.split("play-sound ")
          s = s[1].split(/\s|\"/)[0]
          @soundBuffer.push(Parser.parseStatement(s))
          SoundManager.playSound(Parser.parseStatement(s))
        # Music playing
        if str.indexOf("play-music") > -1
          s = str.split("play-music ")
          s = s[1].split(/\s|\"/)[0]
          @musicBuffer.push(Parser.parseStatement(s))
          SoundManager.startMusic(Parser.parseStatement(s))
        # Music stopping
        if str.indexOf("stop-music") > -1
          s = str.split("stop-music ")
          s = s[1].split(/\s|\"/)[0]
          @stopMusicBuffer.push(Parser.parseStatement(s))
          SoundManager.stopMusic(Parser.parseStatement(s))
        # Pausing
        if str.indexOf("pause") > -1
          s = str.split("pause ")
          s = s[1].split(/\s|\"/)[0]
          @pause = s
          if @pause is "input"
            UI.showContinueButton(true)
        # Command executing
        if str.indexOf("execute-command") > -1
          s = str.split("execute-command ")
          s = s[1].split(/\s|\"/)[0]
          @executeBuffer.push(s)
          if s isnt undefined
            eval(novelData.parsedJavascriptCommands[parseInt(s.substring(4,s.length))])
        # Speed setting
        if str.indexOf("set-speed") > -1
          s = str.split("set-speed ")
          s = s[1].split(/\s|\"/)[0]
          @interval = Parser.parseStatement(s)
          @speedMod = true
        # Speed resetting
        if str.indexOf("default-speed") > -1
          @interval = @defaultInterval
          @speedMod = false
        # Scroll sound setting
        if str.indexOf("set-scroll-sound") > -1
          s = str.split("set-scroll-sound ")
          s = s[1].split(/\s|\"/)[0]
          @scrollSound = Parser.parseStatement(s)
        # Scroll sound resetting
        if str.indexOf("default-scroll-sound") > -1
          @scrollSound = undefined
      @currentOffset = i
      @offsetChanged = true


### UI SCRIPTS ###

class UI

  # Create instance
  instance = null
  constructor: ->
    if instance
      return instance
    else
      instance = this

  @init: ->
    n = document.getElementsByTagName('novel')[0];
    if not n
      n = document.getElementById('novel-area')
    if n
      d = document.createElement('div');
      d.id = "novel-area"
      d.innerHTML = '<div id="novel-style-area">
        <div id="novel-notification-wrapper">
          <div id="novel-save-notification" class="novel-notification">
            <p class="novel-save-text"></p>
            <p><textarea name="save-text" readonly></textarea></p>
            <p><button type="button" class="novel-close-button" onclick="UI.closeSaveNotification()"></button><button type="button" class="novel-copy-button" onclick="UI.copyText()"></button></p>
          </div>
          <div id="novel-load-notification" class="novel-notification">
            <p class="novel-load-text"></p>
            <p><textarea name="load-text"></textarea></p>
            <p><button type="button" class="novel-close-button" onclick="UI.closeLoadNotification(false)"></button><button type="button" class="novel-load-button" onclick="UI.closeLoadNotification(true)"></button></p>
          </div>
        </div>
        <div id="novel-text-area">
          <div id="novel-text"></div>
          <button type="button" class="novel-skip-button" onclick="TextPrinter.complete()"></button>
          <button type="button" class="novel-continue-button" onclick="TextPrinter.unpause()"></button>
        </div>
        <div id="novel-choices-area">
          <ul id="novel-choice-list"></ul>
        </div>
        <div id="novel-inventory-area">
          <h5 class="novel-inventory-title"></h5>
          <ul id="novel-inventory"></ul>
        </div>
        <div id="novel-hidden-inventory-area">
          <h5 class="novel-hidden-inventory-title"></h5>
          <ul id="novel-hidden-inventory"></ul>
        </div>
        <div id="novel-save-area">
          <button type="button" class="novel-save-button" onclick="NovelManager.saveData()"></button>
          <button type="button" class="novel-load-button" onclick="UI.showLoadNotification()"></button>
        </div>
      </div>';
      n.parentNode.insertBefore(d, n);
      n.parentNode.removeChild(n);
      @updateUILanguage()
      return

  @updateUILanguage: () ->
    document.getElementsByClassName("novel-save-text")[0].innerHTML = LanguageManager.getUIString('saveText')
    document.getElementsByClassName("novel-load-text")[0].innerHTML = LanguageManager.getUIString('loadText')
    for i in document.getElementsByClassName("novel-close-button")
      i.innerHTML = LanguageManager.getUIString('closeButton')
    document.getElementsByClassName("novel-copy-button")[0].innerHTML = LanguageManager.getUIString('copyButton')
    document.getElementsByClassName("novel-skip-button")[0].innerHTML = LanguageManager.getUIString('skipButton')
    document.getElementsByClassName("novel-continue-button")[0].innerHTML = LanguageManager.getUIString('continueButton')
    document.getElementsByClassName("novel-inventory-title")[0].innerHTML = LanguageManager.getUIString('inventoryTitle')
    document.getElementsByClassName("novel-hidden-inventory-title")[0].innerHTML = LanguageManager.getUIString('hiddenInventoryTitle')
    document.getElementsByClassName("novel-save-button")[0].innerHTML = LanguageManager.getUIString('saveButton')
    for i in document.getElementsByClassName("novel-load-button")
      i.innerHTML = LanguageManager.getUIString('loadButton')

  @updateStyle: (style) ->
    e = document.getElementById("novel-style-area")
    if style is undefined
      style = ""
    e.setAttribute( 'class', style );

  @disableSkipButton: ->
    if document.querySelector(".novel-skip-button") isnt null
      document.querySelector(".novel-skip-button").disabled = true;

  @enableSkipButton: ->
    if document.querySelector(".novel-skip-button") isnt null
      document.querySelector(".novel-skip-button").disabled = true;

  @showSkipButton: (show) ->
    e = document.getElementsByClassName("novel-skip-button")[0]
    if show && novelData.novel.settings.showSkipButton
      e.style.display = "inline"
    else
      e.style.display = "none"

  @showChoicesArea: (show) ->
    e = document.getElementById("novel-choices-area")
    if show
      e.style.display = "inline"
    else
      e.style.display = "none"

  @showInventoryArea: (show) ->
    e = document.getElementById("novel-inventory-area")
    if show
      e.style.display = "inline"
    else
      e.style.display = "none"

  @showHiddenInventoryArea: () ->
    e = document.getElementById("novel-hidden-inventory-area")
    if novelData.novel.settings.debugMode
      e.style.display = "inline"
    else
      e.style.display = "none"

  @showSaveButtons: (show) ->
    e = document.getElementById("novel-save-area")
    if show
      e.style.display = "inline"
    else
      e.style.display = "none"

  @showContinueButton: (show) ->
    if document.querySelector(".novel-continue-button") isnt null
      if not show
        document.querySelector(".novel-continue-button").style.display = 'none'
      else
        document.querySelector(".novel-continue-button").style.display = 'inline'

  @updateText: (text) ->
    e = document.getElementById("novel-text")
    e.innerHTML = text

  # Show the save notification window, and update its text
  @showSaveNotification: (text) ->
    e = document.getElementById("novel-save-notification")
    textArea = e.querySelectorAll("textarea")
    textArea[0].value = text
    e.style.display = 'block';

  # Close the save notification window
  @closeSaveNotification: ->
    e = document.getElementById("novel-save-notification")
    e.style.display = 'none';

  # Show the load notification window
  @showLoadNotification: ->
    if novelData.novel.settings.saveMode is "text"
      e = document.getElementById("novel-load-notification")
      e.style.display = 'block';
    else
      NovelManager.loadGame()

  # Close the load notification - if load, then load a save. ChangeScene defines whether the scene should be updated or not.
  @closeLoadNotification: (load, changeScene) ->
    e = document.getElementById("novel-load-notification")
    if load
      textArea = e.querySelectorAll("textarea")
      NovelManager.loadData(textArea[0].value,changeScene)
      textArea[0].value = ""
    e.style.display = 'none'

  # Copy text from the save notification
  @copyText: ->
    copyTextarea = document.getElementById("novel-save-notification").querySelector("textarea")
    copyTextarea.select()
    try
      successful = document.execCommand('copy')
    catch err
      console.error "Error! Copying to clipboard failed: "+err

  # Update the values of the input fields
  @updateInputs: (needForUpdate) ->
    inputs = document.getElementById("novel-area").querySelectorAll("input")
    for i in inputs
      for a in novelData.novel.inventories[novelData.novel.currentInventory]
        if a.name is i.className.substring(6,i.className.length)
          a.value = Util.stripHTML(i.value)
          if needForUpdate
            SceneManager.updateScene(novelData.novel.currentScene,true)

  # Reset all choices
  @resetChoices: () ->
    choiceArea = document.getElementById("novel-choice-list")
    while choiceArea.firstChild
      choiceArea.removeChild(choiceArea.firstChild)

  # Reset the inventories
  @resetInventories: () ->
    inventoryArea = document.getElementById("novel-inventory")
    while inventoryArea.firstChild
      inventoryArea.removeChild(inventoryArea.firstChild)
    inventoryArea = document.getElementById("novel-hidden-inventory")
    while inventoryArea.firstChild
      inventoryArea.removeChild(inventoryArea.firstChild)

  # Update the choices
  @updateChoices: () ->
    @resetChoices()
    choiceArea = document.getElementById("novel-choice-list")
    i = 0
    for i in [0 ... novelData.novel.currentScene.choices.length]
      choice = novelData.novel.currentScene.choices[i]
      if choice.text
        choice.parsedText = Parser.parseText(LanguageManager.getCorrectLanguageString(choice.text))
        if SceneManager.requirementsFilled(choice)
          li = document.createElement("li")
          li.innerHTML = '<a href="#"; onclick="SceneManager.selectChoiceById(' + i + ')">' + choice.parsedText + '</a>'
          choiceArea.appendChild(li)
        else if choice.alwaysShow || novelData.novel.settings.alwaysShowDisabledChoices
          li = document.createElement("li")
          li.innerHTML = choice.parsedText
          choiceArea.appendChild(li)

  # Update the inventory items
  @updateInventories: () ->
    @resetInventories()
    inventoryArea = document.getElementById("novel-inventory")
    hiddenInventoryArea = document.getElementById("novel-hidden-inventory")
    for item in novelData.novel.inventories[novelData.novel.currentInventory]
      targetInventory = hiddenInventoryArea
      if not item.hidden or item.hidden is undefined
        targetInventory = inventoryArea
      if item.value > 0 or isNaN item.value
        li = document.createElement("li")
        li.class = "novel-inventory-item"
        innerHTML = LanguageManager.getItemAttribute(item,'displayName') + ' - ' + item.value
        innerHTML = innerHTML + '<ul class="novel-inventory-item-info">'
        if item.description
          innerHTML = innerHTML + '<li class="novel-inventory-item-description">' + LanguageManager.getItemAttribute(item,'description') + '</li>'
        innerHTML = innerHTML + '</ul>'
        li.innerHTML = innerHTML
        targetInventory.appendChild(li)


### UTILITY SCRIPTS ###

class Util
  instance = null
  constructor: ->
    if instance
      return instance
    else
      instance = this

  # Check if a value is even or not
  @isEven: (n) ->
    n % 2 is 0

  # Check if a value is odd or not
  @isOdd: (n) ->
    Math.abs(n % 2) is 1

  # Remove HTML tags from a string - used to clean input
  @stripHTML: (text) ->
    regex = /(<([^>]+)>)/ig
    text.replace regex, ''

  # Check if a variable is the chosen format
  @checkFormat: (s, format) ->
    if format is 'array'
      if Object::toString.call(s) is '[object Array]'
        return true
      else
        console.error "ERROR: Invalid input format (should be " + format + ")"
        return false
    else if format is 'arrayOrString'
      if Object::toString.call(s) is '[object Array]' || typeof s is 'string'
        return true
      else
        console.error "ERROR: Invalid input format (should be " + format + ")"
        return false
    else
      if typeof s is format
        return true
      else
        console.error "ERROR: Invalid input format (should be " + format + ")"
        return false

  # Check if the string has valid parentheses
  @validateParentheses: (s) ->
    open = 0
    for i in s
      if i is "("
        open++
      if i is ")"
        if open > 0
          open--
        else
          return false
    if open is 0
      return true
    else
      return false

  # Check if [] parentheses are valid - ignore /[ and /]
  @validateTagParentheses: (s) ->
    open = 0
    index = 0
    for i in s
      if i is "["
        if s[index-1]
          if s[index-1] isnt "/"
            open++
        else
          open++
      if i is "]"
        if s[index-1]
          if s[index-1] isnt "/"
            if open > 0
              open--
            else
              return false
        else
          if open > 0
            open--
          else
            return false
      index++
    if open is 0
      return true
    else
      return false

  # Merge two object arrays into one
  @mergeObjArrays = (list1, list2) ->
    result = {}
    list1.concat(list2).forEach (item) ->
      name = item.name
      row = result[name]
      if !row
        result[name] = item
        return
      for column of item
        row[column] = item[column]
      return
    finalResult = Object.keys(result).map((name) ->
      result[name]
    )
    return finalResult


### GLOBAL GAME DATA ###

novelData = {
  novel: null
  choices: null
  debugMode: false
  status: "Loading"
  inventoryHidden: false
  choicesHidden: false
  printedText: ""
  parsedJavascriptCommands: []
  music: []
  csvEnabled: false
  markdownEnabled: false
}

novelPath = './novel'

if typeof Papa isnt "undefined"
   novelData.csvEnabled = true

if typeof marked isnt "undefined"
   novelData.markdownEnabled = true


### And finally, start the game... ###

NovelManager.start()
